/* 
 * Copyright (C) 2012 SusyFit Collaboration
 * All rights reserved.
 *
 * For the licensing terms see doc/COPYING.
 */

#ifndef FLAVOUR_H
#define	FLAVOUR_H

#include "HeffDF2.h"
#include "HeffDS1.h"
#include "HeffDB1.h"
#include "MVll.h"
#include "MPll.h"
#include <boost/tuple/tuple.hpp>

class StandardModel;

/**
 * @class Flavour
 * @ingroup Flavour
 * @brief The parent class in Flavour for calculating all the Wilson coefficients for various Flavor Violating processes. 
 * @author HEPfit Collaboration
 * @copyright GNU General Public License
 * @details The Flavour class aggregates the Wilson coefficients for each of the processes generated by the model by calling the Hamiltonians.
 */

class Flavour {
public:

    /**
     * @brief The constructor.
     * @param[in] SM_i a reference to an object of the class StandardModel
     */
    Flavour(const StandardModel& SM_i) : 
        HDF2(SM_i), 
        HDB1(SM_i), 
        HDS1(SM_i)
    {
        myMVll_BdKstarmu = new MVll(SM_i, StandardModel::B_D, StandardModel::K_star, StandardModel::MU);
        myMVll_BdKstarel = new MVll(SM_i, StandardModel::B_D, StandardModel::K_star, StandardModel::ELECTRON);
        myMVll_Bsphimu = new MVll(SM_i, StandardModel::B_S, StandardModel::PHI, StandardModel::MU);
        myMVll_Bsphiel = new MVll(SM_i, StandardModel::B_S, StandardModel::PHI, StandardModel::ELECTRON);
        myMPll_BpKmu = new MPll(SM_i, StandardModel::B_P, StandardModel::K_P, StandardModel::MU);
        myMPll_BpKel = new MPll(SM_i, StandardModel::B_P, StandardModel::K_P, StandardModel::ELECTRON);
        
        update_BdKstarmu = true;
        update_BdKstarel = true;
        update_Bsphimu = true;
        update_Bsphiel = true;
        update_BpKmu = true;
        update_BpKel = true;
    };
    
    /**
     * @brief The member that returns an object of the class HeffDF2.
     * @return returns the Hamiltonian for the \f$ \Delta F = 2 \f$ processes
     * 
     */
    const HeffDF2& getHDF2() const {
        return HDF2;
    }
    
    /**
     * @brief The member that returns an object of the class HeffDS1.
     * @return returns the Hamiltonian for the \f$ \Delta S = 1 \f$ processes.
     * 
     */
    const HeffDS1& getHDS1() const {
        return HDS1;
    }
    
    /**
     * @brief The member that returns an object of the class HeffDB1.
     * @return returns the Hamiltonian for the \f$ \Delta B = 1 \f$ processes.
     * 
     */
    const HeffDB1& getHDB1() const {
        return HDB1;
    }
    
     /**
     * @brief Computes the Wilson coefficient for the process \f$ B_d \to \mu \mu \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the Wilson coefficients for the process \f$ B_d \to \mu \mu \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffBd(double mu, schemes scheme = NDR) {
        return HDF2.ComputeCoeffBd(mu, scheme);
    }

    /**
     * @brief Computes the Wilson coefficient for the process \f$ B_s \to \mu \mu \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the Wilson coefficients for the process \f$ B_s \to \mu \mu \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffBs(double mu, schemes scheme = NDR) {
        return HDF2.ComputeCoeffBs(mu, scheme);
    }

    gslpp::vector<gslpp::complex>** ComputeCoeffdd(double mu, schemes scheme = NDR) {
        return HDF2.ComputeCoeffdd(mu, scheme);
    }
    
    gslpp::vector<gslpp::complex>** ComputeCoeffK(double mu, schemes scheme = NDR) {
        return HDF2.ComputeCoeffK(mu, scheme);
    }
    
    gslpp::vector<gslpp::complex>** ComputeCoeffmK(double mu, schemes scheme = NDR) {
        return HDF2.ComputeCoeffmK(mu, scheme);
    }
    
    gslpp::vector<gslpp::complex>** ComputeCoeffDS1PP(double mu, schemes scheme = NDR) {
        return HDS1.ComputeCoeffDS1PP(mu, scheme);
    }
    
    gslpp::vector<gslpp::complex>** ComputeCoeffDS1pnunu() {
        return HDS1.ComputeCoeffDS1pnunu();
    }
    
    gslpp::vector<gslpp::complex>** ComputeCoeffDS1mumu() {
        return HDS1.ComputeCoeffDS1mumu();
    }
    
    /**
     * @brief Computes the Wilson coefficient for the process \f$ B_s \to \mu \mu \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the Wilson coefficients for the process \f$ B_s \to \mu \mu \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffsmumu(double mu, schemes scheme = NDR) {
        return HDB1.ComputeCoeffsmumu(mu, scheme);
    }
    
    /**
     * @brief Computes the Wilson coefficient for the process \f$ B_d \to \mu \mu \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the Wilson coefficients for the process \f$ B_d \to \mu \mu \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffdmumu(double mu, schemes scheme = NDR) {
        return HDB1.ComputeCoeffdmumu(mu, scheme);
    }
    
    /**
     * @brief Computes the Wilson coefficient for the process \f$ B_d \to \tau \nu \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the Wilson coefficients for the process \f$ B_d \to \tau \nu \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffbtaunu() {
        return HDB1.ComputeCoeffbtaunu();
    }
    
    gslpp::vector<gslpp::complex>** ComputeCoeffsnunu() {
        return HDB1.ComputeCoeffsnunu();
    }
    
    gslpp::vector<gslpp::complex>** ComputeCoeffdnunu() {
        return HDB1.ComputeCoeffdnunu();
    }
    
    /**
     * @brief Computes the Wilson coefficient for the process \f$ b \to s \gamma \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the Wilson coefficients for the process \f$ b \to s \gamma \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffsgamma(double mu, schemes scheme = NDR) {
        return HDB1.ComputeCoeffsgamma(mu, scheme);
    }
    
    /**
     * @brief Computes the chirality flipped Wilson coefficient for the process \f$ b \to s \gamma \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the chirality flipped Wilson coefficients for the process \f$ b \to s \gamma \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffprimesgamma(double mu, schemes scheme = NDR) {
        return HDB1.ComputeCoeffprimesgamma(mu, scheme);
    }
    
    /**
     * @brief Computes the Wilson coefficient for the process \f$ B \to V/P \ell^+ \ell^- \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the Wilson coefficients for the process \f$ B \to V/P \ell^+ \ell^- \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffBMll(double mu, schemes scheme = NDR) {
        return HDB1.ComputeCoeffBMll(mu, scheme);
    }
    
    /**
     * @brief Computes the chirality flipped Wilson coefficient for the process \f$ B \to V/P \ell^+ \ell^- \f$.
     * @param[in] mu the lower matching scale for the process
     * @param[in] scheme the scheme in which the Wilson Coefficients need to be calculated
     * @return returns the chirality flipped Wilson coefficients for the process \f$ B \to V/P \ell^+ \ell^- \f$
     * 
     */
    gslpp::vector<gslpp::complex>** ComputeCoeffprimeBMll(double mu, schemes scheme = NDR) {
        return HDB1.ComputeCoeffprimeBMll(mu, scheme);
    }
    
    /**
     * @brief Returns the initial and final state dependent object for \f$ B \to V \ell^+ \ell^- \f$.
     * @param[in] meson_i specifies the meson in the initial state
     * @param[in] vector_i specifies the vector in the final state
     * @param[in] lepton_i specifies the lepton in the final state
     * @return returns a pointer to the initial and final state dependent object for the process \f$ B \to V \ell^+ \ell^- \f$
     * 
     */
    MVll* getMVll(StandardModel::meson meson_i, StandardModel::meson vector_i, StandardModel::lepton lep_i) {
        if (meson_i == StandardModel::B_D && vector_i == StandardModel::K_star && lep_i == StandardModel::MU) return myMVll_BdKstarmu;
        if (meson_i == StandardModel::B_D && vector_i == StandardModel::K_star && lep_i == StandardModel::ELECTRON) return myMVll_BdKstarel;
        if (meson_i == StandardModel::B_S && vector_i == StandardModel::PHI && lep_i == StandardModel::MU) return myMVll_Bsphimu;
        if (meson_i == StandardModel::B_S && vector_i == StandardModel::PHI && lep_i == StandardModel::ELECTRON) return myMVll_Bsphiel;
        else throw std::runtime_error("Flavour: Decay channel not implemented.");
    }
    
    /**
     * @brief Returns the initial and final state dependent object for \f$ B \to P \ell^+ \ell^- \f$.
     * @param[in] meson_i specifies the meson in the initial state
     * @param[in] vector_i specifies the vector in the final state
     * @param[in] lepton_i specifies the lepton in the final state
     * @return returns a pointer to the initial and final state dependent object for the process \f$ B \to P \ell^+ \ell^- \f$
     * 
     */
    MPll* getMPll(StandardModel::meson meson_i, StandardModel::meson pseudoscalar_i, StandardModel::lepton lep_i) {
        if (meson_i == StandardModel::B_P && pseudoscalar_i == StandardModel::K_P && lep_i == StandardModel::MU) return myMPll_BpKmu;
        if (meson_i == StandardModel::B_P && pseudoscalar_i == StandardModel::K_P && lep_i == StandardModel::ELECTRON) return myMPll_BpKel;
        else throw std::runtime_error("Flavour: Decay channel not implemented.");
    }
    
    /**
     * @brief sets the update flag for the initial and final state dependent object for \f$ B \to V \ell^+ \ell^- \f$.
     * @param[in] meson_i specifies the meson in the initial state
     * @param[in] vector_i specifies the vector in the final state
     * @param[in] lepton_i specifies the lepton in the final state
     * 
     */
    void setUpdateFlag(StandardModel::meson meson_i, StandardModel::meson meson_j, StandardModel::lepton lep_i, bool updated_i){
        if (meson_i == StandardModel::B_D && meson_j == StandardModel::K_star && lep_i == StandardModel::MU) {update_BdKstarmu = updated_i; return;}
        if (meson_i == StandardModel::B_D && meson_j == StandardModel::K_star && lep_i == StandardModel::ELECTRON) {update_BdKstarel = updated_i; return;}
        if (meson_i == StandardModel::B_S && meson_j == StandardModel::PHI && lep_i == StandardModel::MU) {update_Bsphimu = updated_i; return;}
        if (meson_i == StandardModel::B_S && meson_j == StandardModel::PHI && lep_i == StandardModel::ELECTRON) {update_Bsphiel = updated_i; return;}
        if (meson_i == StandardModel::B_P && meson_j == StandardModel::K_P && lep_i == StandardModel::MU) {update_BpKmu = updated_i; return;}
        if (meson_i == StandardModel::B_P && meson_j == StandardModel::K_P && lep_i == StandardModel::ELECTRON) {update_BpKel = updated_i; return;}
        else throw std::runtime_error("Flavour: Wrong update flag requested.");
    }
    
    /**
     * @brief gets the update flag for the initial and final state dependent object for \f$ B \to V \ell^+ \ell^- \f$.
     * @param[in] meson_i specifies the meson in the initial state
     * @param[in] vector_i specifies the vector in the final state
     * @param[in] lepton_i specifies the lepton in the final state
     * 
     */
    bool getUpdateFlag(StandardModel::meson meson_i, StandardModel::meson meson_j, StandardModel::lepton lep_i){
        if (meson_i == StandardModel::B_D && meson_j == StandardModel::K_star && lep_i == StandardModel::MU) return update_BdKstarmu;
        if (meson_i == StandardModel::B_D && meson_j == StandardModel::K_star && lep_i == StandardModel::ELECTRON) return update_BdKstarel;
        if (meson_i == StandardModel::B_S && meson_j == StandardModel::PHI && lep_i == StandardModel::MU) return update_Bsphimu;
        if (meson_i == StandardModel::B_S && meson_j == StandardModel::PHI && lep_i == StandardModel::ELECTRON) return update_Bsphiel;
        if (meson_i == StandardModel::B_P && meson_j == StandardModel::K_P && lep_i == StandardModel::MU) return update_BpKmu;
        if (meson_i == StandardModel::B_P && meson_j == StandardModel::K_P && lep_i == StandardModel::ELECTRON) return update_BpKel;
        else throw std::runtime_error("Flavour: Wrong update flags requested.");
    }
    
    /**
     * @brief a member used for the caching for \f$ B \to V \ell^+ \ell^- \f$.
     * 
     */
    void setSMupdated(){
        update_BdKstarmu = true;
        update_BdKstarel = true;
        update_Bsphimu = true;
        update_Bsphiel = true;
        update_BpKmu = true;
        update_BpKel = true;
    }
    
private:
    
    HeffDF2 HDF2;///< An Object for the Hamiltonian of the \f$ \Delta F = 2 \f$ processes.
    HeffDB1 HDB1;///< An Object for the Hamiltonian of the \f$ \Delta B = 1 \f$ processes.
    HeffDS1 HDS1;///< An Object for the Hamiltonian of the \f$ \Delta S = 1 \f$ processes.
    MVll* myMVll_BdKstarmu;///< An object for the process \f$ B_d \to K^* \mu^+ \mu^- \f$.
    MVll* myMVll_BdKstarel;///< An object for the process \f$ B_d \to K^* \e^+ \e^- \f$.
    MVll* myMVll_Bsphimu;///< An object for the process \f$ B_s \to \phi \mu^+ \mu^- \f$.
    MVll* myMVll_Bsphiel;///< An object for the process \f$ B_s \to \phi \e^+ \e^- \f$.
    MPll* myMPll_BpKmu;///< An object for the process \f$ B^+ \to K^+ \mu^+ \mu^- \f$.
    MPll* myMPll_BpKel;///< An object for the process \f$ B^+ \to K^+ \e^+ \e^- \f$.
    bool update_BdKstarmu;///< A flag used for caching of \f$ B_d \to K^* \mu^+ \mu^- \f$.
    bool update_BdKstarel;///< A flag used for caching of \f$ B_d \to K^* \e^+ \e^- \f$.
    bool update_Bsphimu;///< A flag used for caching of \f$ B_s \to \phi \mu^+ \mu^- \f$.
    bool update_Bsphiel;///< A flag used for caching of \f$ B_s \to \phi \e^+ \e^- \f$.
    bool update_BpKmu;///< A flag used for caching of \f$ B^+ \to K^+ \mu^+ \mu^- \f$.
    bool update_BpKel;///< A flag used for caching of \f$ B^+ \to K^+ \e^+ \e^- \f$.
};

/**
 * @}
 */

#endif	/* FLAVOUR_H */